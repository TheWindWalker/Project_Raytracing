#include <iostream>
#include "../FreeImage/FreeImage.h"
#include "SDL.h"
#include <time.h>
#include <chrono>
#include <thread>
#include "Camera.h"
#include "Object.h"

#define WIDTH 500
#define HEIGHT 500
#define BitsPerPixel 24

//FreeImage_Save(FIF_PNG, bitmap, "export.png", 0); //Export an image to a file

/** Initialise a SDL window and return a pointer to it. */
SDL_Window *get_sdl_window(int width, int height) {
	if (SDL_Init(SDL_INIT_VIDEO) < 0) {
		std::cout << "SDL couldn't initialise: %s.\n"<< SDL_GetError() <<"\n";
		exit(5);
	}

	SDL_Window *sdl_window;
	sdl_window = SDL_CreateWindow("Raytracing",
		SDL_WINDOWPOS_CENTERED,
		SDL_WINDOWPOS_CENTERED,
		width,
		height,
		SDL_WINDOW_BORDERLESS);

	return sdl_window;
}

/*Return the surface painted with the image*/
SDL_Surface* get_surface_image(FIBITMAP *image)
{
	//Assign the image to the surface
	// Loaded image is upside down, so flip it. for compatibility with SDL
	FreeImage_FlipVertical(image);

	SDL_Surface *sdl_surface = SDL_CreateRGBSurfaceFrom(
		FreeImage_GetBits(image),
		FreeImage_GetWidth(image),
		FreeImage_GetHeight(image),
		FreeImage_GetBPP(image),
		FreeImage_GetPitch(image),
		FreeImage_GetRedMask(image),
		FreeImage_GetGreenMask(image),
		FreeImage_GetBlueMask(image),
		0
	);

	if (sdl_surface == NULL) {
		std::cout << "Failed to create surface: %s\n" << SDL_GetError() << "\n";
		exit(4);
	}
	return sdl_surface;
}


void fill_image(FIBITMAP *image)
{
	RGBQUAD color;
	if (!image)
	{
		std::cout << "Error No image, fill_image()\n";
		exit(404);
	}
	//Draws a gradient from blue to green:
	for (int i = 0; i < WIDTH; i++) {
		for (int j = 0; j < HEIGHT; j++) {
			color.rgbRed = 0;
			color.rgbGreen = (double)i / WIDTH * 255.0;
			color.rgbBlue = (double)j / HEIGHT * 255.0;
			FreeImage_SetPixelColor(image, i, j, &color);
		}
	}
}
void random_image(FIBITMAP *image)
{
	RGBQUAD color;
	if (!image)
	{
		std::cout << "Error No image, fill_image()\n";
		exit(1);
	}
	//Draws a gradient from blue to green:
	for (int i = 0; i < WIDTH; i++) {
		for (int j = 0; j < HEIGHT; j++) {
			color.rgbRed = rand() % 255;
			color.rgbGreen = rand() % 255;
			color.rgbBlue = rand() % 255;
			FreeImage_SetPixelColor(image, i, j, &color);
		}
	}
}
void render_windows()
{
	//Create a windows with the same width and height
	SDL_Window *sdl_window = get_sdl_window(WIDTH, HEIGHT);
	FIBITMAP *bitmap = FreeImage_Allocate(WIDTH, HEIGHT, BitsPerPixel);

	//Create the renderer only one time for the window
	SDL_Renderer* renderer = SDL_CreateRenderer(sdl_window, -1, 0);
	if (renderer == NULL) {
		std::cout << "Failed to render: %s\n" << SDL_GetError() << "\n";
		exit(1);
	}

	/*The bitmap will be generated by our software*/
	fill_image(bitmap); //Fill image with black (first image only)

	//Render the image in a surface
	SDL_Surface* sdl_surface = get_surface_image(bitmap);

	//Create a texture with the surface and fill the renderer
	SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, sdl_surface);
	if (texture == NULL) {
		std::cout << "Failed to load image\n";
		exit(1);
	}

	SDL_RenderClear(renderer);//Clean the renderer
	SDL_RenderCopy(renderer, texture, NULL, NULL);//Copy the texture into the renderer
	SDL_RenderPresent(renderer);//Render the renderer in the window

	int keypressed = 0;
	SDL_Event e;
	while (!keypressed) {
		std::this_thread::sleep_for(std::chrono::milliseconds(16));//Pause pour ne rendre que environ 60 fps

		random_image(bitmap); //Fill image with random colors

		//Render the image in a surface
		sdl_surface = get_surface_image(bitmap);

		//Create a texture with the surface and fill the renderer
		texture = SDL_CreateTextureFromSurface(renderer, sdl_surface);
		if (texture == NULL) {
			std::cout << "Failed to load image\n";
			exit(1);
		}

		SDL_RenderClear(renderer);//Clean the renderer
		SDL_RenderCopy(renderer, texture, NULL, NULL);//Copy the texture into the renderer
		SDL_RenderPresent(renderer);//Render the renderer in the window

		while (SDL_PollEvent(&e)) {
			//std::cout << "Key pressed: " << e.type << "\n";
			if (e.type == SDL_KEYDOWN) {
				keypressed = 1;
			}
		}
	}

	//Wait for a key press
	//event_loop();//Old

	//Unloading from memory and clean quit
	FreeImage_Unload(bitmap);	
	SDL_FreeSurface(sdl_surface);
	SDL_DestroyTexture(texture);
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(sdl_window);

	
	
}
int main(int argc, char* argv[])
{	
	srand(time(NULL));
	render_windows(); // Affiche une fen�tre avec l'image g�n�r�e (boucle attendant une pression sur une touche)
	return 0;
}