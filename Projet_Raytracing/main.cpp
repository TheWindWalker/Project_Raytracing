#include <iostream>
#include <string>
#include "../FreeImage/FreeImage.h"
#include "SDL.h"
#include <time.h>
#include <chrono>
#include <thread>

/*Include our classes*/
#include "game.h"

/*Definition for image*/
#define WIDTH 500
#define HEIGHT 500
#define BitsPerPixel 24
/*Definition for processing*/
#define DEBUG 1
#define PRINT_WINDOWS 0

//FreeImage_Save(FIF_PNG, bitmap, "export.png", 0); //Export an image to a file

/** Initialise a SDL window and return a pointer to it. */
SDL_Window *get_sdl_window(int width, int height) {
	if (SDL_Init(SDL_INIT_VIDEO) < 0) {
		std::cout << "SDL couldn't initialise: %s.\n"<< SDL_GetError() <<"\n";
		exit(5);
	}

	SDL_Window *sdl_window;
	sdl_window = SDL_CreateWindow("Raytracing",
		SDL_WINDOWPOS_CENTERED,
		SDL_WINDOWPOS_CENTERED,
		width,
		height,
		SDL_WINDOW_BORDERLESS);

	return sdl_window;
}

/*Return the surface painted with the image*/
SDL_Surface* get_surface_image(FIBITMAP *image)
{
	//Assign the image to the surface
	// Loaded image is upside down, so flip it. for compatibility with SDL
	FreeImage_FlipVertical(image);

	SDL_Surface *sdl_surface = SDL_CreateRGBSurfaceFrom(
		FreeImage_GetBits(image),
		FreeImage_GetWidth(image),
		FreeImage_GetHeight(image),
		FreeImage_GetBPP(image),
		FreeImage_GetPitch(image),
		FreeImage_GetRedMask(image),
		FreeImage_GetGreenMask(image),
		FreeImage_GetBlueMask(image),
		0
	);

	if (sdl_surface == NULL) {
		std::cout << "Failed to create surface: %s\n" << SDL_GetError() << "\n";
		exit(4);
	}
	return sdl_surface;
}


void fill_image(FIBITMAP *image)
{
	RGBQUAD color;
	if (!image)
	{
		std::cout << "Error No image, fill_image()\n";
		exit(404);
	}
	//Draws a gradient from blue to green:
	for (int i = 0; i < WIDTH; i++) {
		for (int j = 0; j < HEIGHT; j++) {
			color.rgbRed = 0;
			color.rgbGreen = (double)i / WIDTH * 255.0;
			color.rgbBlue = (double)j / HEIGHT * 255.0;
			FreeImage_SetPixelColor(image, i, j, &color);
		}
	}
}
void random_image(FIBITMAP *image)
{
	RGBQUAD color;
	if (!image)
	{
		std::cout << "Error No image, fill_image()\n";
		exit(1);
	}
	//Draws a gradient from blue to green:
	for (int i = 0; i < WIDTH; i++) {
		for (int j = 0; j < HEIGHT; j++) {
			color.rgbRed = rand() % 255;
			color.rgbGreen = rand() % 255;
			color.rgbBlue = rand() % 255;
			FreeImage_SetPixelColor(image, i, j, &color);
		}
	}
}
void render_windows()
{
	/*The bitmap will be generated by our software*/
	FIBITMAP *bitmap = FreeImage_Allocate(WIDTH, HEIGHT, BitsPerPixel);
	fill_image(bitmap); //Fill image with black (first image only)
	
	//Create a windows with the same width and height
	SDL_Window* sdl_window = get_sdl_window(WIDTH, HEIGHT);
	SDL_Surface* sdl_surface = get_surface_image(bitmap);
	SDL_Renderer* renderer = SDL_CreateRenderer(sdl_window, -1, 0);
	if (renderer == NULL) {
		std::cout << "Failed to render: %s\n" << SDL_GetError() << "\n";
		exit(1);
	}
	SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, sdl_surface);
	if (texture == NULL) {
		std::cout << "Failed to load image\n";
		exit(1);
	}

	int keypressed = 0;
	SDL_Event e;
	while (!keypressed) {
		std::this_thread::sleep_for(std::chrono::milliseconds(16));//Pause pour ne rendre que environ 60 fps

		random_image(bitmap); //Fill image with random colors
		if (PRINT_WINDOWS == 1)
		{
			//Render the image in a surface
			sdl_surface = get_surface_image(bitmap);

			//Create a texture with the surface and fill the renderer
			texture = SDL_CreateTextureFromSurface(renderer, sdl_surface);
			if (texture == NULL) {
				std::cout << "Failed to load image\n";
				exit(1);
			}

			SDL_RenderClear(renderer);//Clean the renderer
			SDL_RenderCopy(renderer, texture, NULL, NULL);//Copy the texture into the renderer
			SDL_RenderPresent(renderer);//Render the renderer in the window
		}
		while (SDL_PollEvent(&e)) {
			//std::cout << "Key pressed: " << e.type << "\n";
			if (e.type == SDL_KEYDOWN) {
				keypressed = 1;
			}
		}
	}

	//Wait for a key press
	//event_loop();//Old

	//Unloading from memory and clean quit
	FreeImage_Unload(bitmap);	
	SDL_FreeSurface(sdl_surface);
	SDL_DestroyTexture(texture);
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(sdl_window);

	
	
}
int main(int argc, char* argv[])
{	
	srand(time(NULL));
	Game game;

	render_windows(); // Affiche une fen�tre avec l'image g�n�r�e (boucle attendant une pression sur une touche)
	return 0;
}